# 编程语言的分类
```bash
编程语言的分类
	根据运行的方式
		编译运行: 源代码->编译器(编译)->程序文件
		解释运行: 源代码->运行时启动的解释器，由解释器边解释边运行
	根据其编程过程中功能的实现是调用库还是调用外部的程序文件
		shell脚本编程
			利用系统上的命令及编程组件进行编程
		完整编程
			利用库或编辑组件进行编程
	根据编程模型: 过程式编程语言、面向对象的编程语言
		程序=指令+数据
			过程式: 以指令为中心来组织代码，数据服务于代码
				顺序执行、选择执行、循环执行
			对象式: 以数据为中心来组织代码，围绕数据来组织指令
				类(class): 实例化对象,method
				代表: java c++ python
				
	shell脚本编程: 过程式编程，解释运行，依赖外部程序文件运行
	
如何写shell脚本
	脚本文件的第一行，顶格:给出shebang，解释器路径，用于指明解释运行当前脚本的解释器程序文件
	常见解释器
		#!/bin/bash
		#!/usr/bin/python
		#!/usr/bin/perl
运行shell脚本
	(1)赋予执行权限，并直接运行此程序文件
		chmod +x /FILE
		/PATH/FILE
	(2)直接运行解释器，将脚本以命令行参数传递给解释器程序
		bash /PATH/FILE
	注意：脚本中的空白行会被解释器忽略
		脚本中，除了shebang，余下所有以\#开头的，都会被视作注释忽略
		
练习:写一个脚本，实现以下功能
	1.显示/etc目录下所有以大写p或小写p开头的文件或目录本身
	2.显示/var目录下所有文件或目录本身，并将显示结果中的小写字母转换为大写后显示
	3.创建临时文件/tmp/myfile.XXX
	
	#!/bin/bash
	ls -d /etc/[pP]*
	ls -d /var/* | tr "a-z" "A-Z"
	mktemp /tmp/myfile.XXX
	
文本编辑器: nano
	行编辑器:sed
	全屏编辑器:vi vim nano
	
	
```
# bash配置文件
```bash
两类
	profile类: 为交互式登录的shell进程提供配置
	bashrc类: 为非交互式登录的shell进程提供配置
登录类型
	交互式登录shell进程
		直接通过某终端输入账号密码后登录打开的shell进程
		使用su命令: su - username | su -l username切换登录
	非交互式登录shell进程
		su username切换登录
		图形界面下打开的终端
		运行脚本
profile类
	全局:对所有用户都生效
		/etc/profile
		/etc/profile.d/*.sh
	用户个人: 仅对当前用户有效
		~/.bash_profile
	功用:
		1.用于定义环境变量
		2.用户运行脚本和命令

bashrc类
	全局
		/etc/bashrc
	个人
		~/.bashrc
	功用
		定义本地变量
		定义命名别名
	注意: 仅管理员可修改全局配置文件
	
交互式登录shell进程文件访问顺序
	/etc/profile->/etc/profile.d/* ->~/.bash_profile-> ~/.bashrc -> /etc/bashrc

非交互式登录shell进程
	~/.bashrc -> /etc/bashrc -> /etc/profile.d/*
	
	
让通过配置文件定义的特性立即生效
	1.通过命令行重新定义一次
	2.让shell进程重读配置文件
		source /path/conf_file
		. /path/conf_file
```
# 文件处理工具及grep、egrep
```bash
Linux上文本处理三剑客
	grep: 文本过滤工具(模式: pattern)工具
	sed: stream editor，流编辑器;文本编辑工具
	awk: linux上实现为gawk，文本报告生成器(格式化文本)

正则表达式: Regual Experssion REGEXP
	由一类特殊字符及文本字符所编写的模式，其中有些字符不表示其字面意义，而是用于表示控制或通配功能
	分两类
		基本正则表达式: BRE
		扩展正则表达式: ERE
	
grep: Global search REgular expression and Print out the line
	作用: 文本搜索工具，根据用户指定的模式对文本进行逐行匹配检查，打印匹配的行
	模式: 由正则表达式的元字符以及文本字符所编写的过滤条件
	
	grep [options] PATTERN [FILE...]
	grep [options] [-e PATTERN | -f FILE] [FILE...] 
	
	选项: 
		--color=auto: 对匹配到的文本着色后高亮显示
		-i: ignorecase,忽略字符的大小写
		-o: 仅显示匹配到的字符本身
		-v: 显示不能被模式匹配到的行
		-E：支持使用扩展的正则表达式元字符
		-q: 静默模式，即不输出任何信息
		
		-A #: after,后#行
		-B #: before,前#行
		-C #: context,前后各#行

egrp
	支持扩展的正则表达式实现类似于grep -E
	egrp [options] PATTERN [FILE...]
		选项
		-i,-o,-v,-q,-A,-B,-C
		-G: 支持基本正则表达式
```
# 基本正则表达式
```bash
字符匹配
	.: 匹配任意单个字符
	[]: 匹配指定范围内的任意单个字符
	[^]: 匹配指定范围外的任意单个字符
		[:dight:] [lower:] [:upper:] [:alpha:] [:alnum:] [:punct:] [:space:]
	
匹配次数: 用在要指定其出现的次数的字符的后面，用于其出现的次数
	*: 匹配其前面的字符任意次; 0,1,多次
	.*: 匹配任意长度的任意字符
	\?: 匹配其前面的字符0次或1次，即可有可无
	\+: 匹配前面的字符1次或多次，至少要出现一次
	\{m\}: 匹配其前面字符m次
	\{m,n\}: 匹配其前面字符至少m次，至多n次
		\{0,n\}: 至多n次
		\{m,\}: 至少m次
		
位置锚定
	^: 行首锚定
	$: 行尾锚定
	^PATTERN$: 匹配整行
		^$: 空白行
		^[[:space:]]*$: 空行或包含空白字符的行
	单词: 非特殊字符组成的连续字符
	\<或\b: 词首锚定，用于单词模式的左侧
	\>或\b: 词尾锚定，用于单词模式的右侧
	\<PATTERN\>: 匹配完整单词
	
练习
	1.显示/etc/passwd文件中不以/bin/bash结尾的行
		grep -v "/bin/bash$" /etc/passwd
	2.找出/etc/passwd文件中的两位数或三位数
		grep "\b[0-9]\{2,3\}\b" /etc/passwd
		grep "\<[0-9]\{2,3\}\>" /etc/passwd
	3.找出/etc/grub2.cfg文件中，以至少一个空白字符开头，且后面非空字符的行
		grep "^[[:space:]]\+[^[:space:]]*" /etc/grub2.cfg
	4.找出"netstat -tan"命令的结果中以'LISTEN'后跟0、1或多个空白字符结尾的行
		netstat -tan | grep "LISTEN[[:space:]]*$"
	
	
分组及引用
	\(\): 将一个或多个字符捆绑在一起

练习: 匹配前面与后面一样的行
	he lover his lover
	he likes his lover
	she likes her liker
	she loves her liker
	grep "\(l...r\).*\1" lover.txt #后向引用
```
# 扩展正则表达式
```bash
扩展正则表达式的元字符
	字符匹配
		.: 任意单个字符
		[]: 指定范围内的任意单个字符
		[^]: 指定范围外的任意单个字符
	
	次数匹配
		*: 任意次，0,1或多次
		?: 0或1次
		+: 最少一次
		{m}: 当前字符至少一次
		{m,n}: 至少m次，至多n次
			{0，n}: 至多n次
			{m,}: 至少m次
	
	位置锚定
		^: 行首锚定
		$: 行尾锚定
		\<,\b: 词首锚定
		\>,\b: 词尾锚定
	
	分组及引用
		(): 分组，括号内的模式匹配到的字符会被记录于正则表达式引擎的内部变量中
		
	或
		a | b: a或者b
			C|cat: C或cat
			(C|c)at: Cat或cat
			
练习
	1.找出/proc/meminfo文件中，所有以大写或小写S开头的行，至少三种
		grep -i "^s" /proc/meminfo
		grep "^[sS]" /proc/meminfo
		egrep "^(s|S)" /proc/meminfo
		
	2.显示当前系统上root,centos或user1用户的相关信息
		egrep "^(root|centos|user1)[^[:alnum:]]" /etc/passwd
		
	3.找出/etc/rc.d/init.d/functions文件中某单词后面跟一个小括号行
		egrep -o  "[_[:alnum:]]+\(\)" /etc/rc.d/init.d/functions
	
	4.使用echo命令输出一绝对路径，使用egrep取出基名
		echo /etc/sysconfig | egrep -o "[[:alnum:]]+/?$"
		echo /etc/sysconfig | egrep -o "[^/]+/?$"
	5.找出ifconfig命令结果中的1-255之间的数值
		ifconfig | egrep "\<([1-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\>"
	6.找出ifconfig命令结果中的IP地址
		ifconfig | grep "inet\>" | tr -s ' ' ":" | cut -d: -f 3
	7.添加用户bash,testbash,basher以及nologin(其sehll为/sbin/nologin);而后找出/etc/passwd文件中用户名与sehll名相同的行
		egrep "^([^:]+).*\1$" /etc/passwd

fgrep: 不支持正则表达式元字符
	当无需要用到元字符去编写模式时，使用fgrep
```
# 文本查看及处理工具wc,cut,sort,uniq,diff,patch
```bash
wc: word count
	wc [OPTION]... [FILE]...
		-l: line
		-w: words
		-c: bytes

cut:
	cut OPTION...[FILE]...
		OPTION:
			-d CHAR: 以指定的字符为分割
			-f: 挑选出的字段
				#: 单个字段
				#-#: 连续多个字段
				#,#: 离散多个字段
				
sort
	sort [OPTION]... [FILE]...
		-n: 基于数值大小而非字符进行排序
		-t CHAR: 指定分隔符
		-k #: 用于排序比较的字段
		-r: 逆序排序
		-f: 忽略字符大小写
		-u: 重复的行只保留一份
		
uniq: 报告或移除重复的行
	uniq [OPTION]... [INPUT[OUTPUT]]
	-c: 显示每行的重复次数
	-u: 仅显示未重复的行
	-d: 仅显示重复过的行
	
diff: compare file line by line
	diff /path/oldFile /path/newFile > /path/patch_file
		-u: 使用unfied机制，即显示要修改的行的上下文，默认3行
		
patch: 向文件打补丁
	patch [options] -i /path/patch_file /path/old_File
	pathch /path/oldFile < /path/patch_file
	
练习：取出ifconfig eno 命令结果中的ip地址
```
# vim编辑模式
```bash
vim: 模式化编辑器
	基本模式:
		编辑模式|普通模式
		输入模式
		末行模式|命令行模式
			内置的命令行接口

模式转换:
	编辑模式->输入模式
		i: insert，在光标所在位置输入，原光标内容向后移动
		a: append，在光标所处后方输入，原光标内容不变
		o: 在光标所处下方打开新行
		O: 在光标所在处上方打开新行
		I: 在光标所在行的行首输入
		A: 在光标所在行的行尾输入
		I: 在光标所在行行首输入
		
关闭文件:
	ZZ: 保存并退出
	:q 退出
	:wq
	:x 保存并退出
	:w /path/to/somefile 修改内容保存到新的文件，源文件不变
	
光标跳转
	字符间跳转
		hl: 右左
		jk: 下上
		
	单词间跳转
		w: 下一个单词词首
		e: 当前或后一个单词词尾
		b: 当前或后一个单词词首
	行首行尾跳转
		^: 跳转至行首的第一个非空白字符
		0: 跳转至行首
		$: 跳转至行尾
	行间跳转
		#G: 跳转至#行
		1G,gg: 第一行
		G: 最后一行

翻屏
	ctrl+f:向文件尾翻一屏
	ctrl+b:向文件首部翻一屏
	ctrl+d:向文件尾部翻半屏
	ctrl+u:向文件首部翻半屏
	ctrl+y:向文件首部翻一行
	center:向文件尾部翻一行
	
vim的编辑命令
	字符编辑
		x: 删除光标所在处的字符
		\#x: 删除光标所在处起始\#个字符
		xp: 交换光标所在处的字符与其后面的字符的位置
		
	替换命令(replace)
		rCHAR: 替换光标所在处的字符
	
	删除命令
		d: 删除命令，可结合光标跳转字符，实现范围删除
			d$: 删除光标所在处到行尾的字符
			d^: 删除光标所在处到行首的字符
			dw: 删除光标所在处到下一个单词词首的字符
			de: 删除光标所在处至当前或后一个单词词尾的字符
			db: 删除光标所在处至当前或前一个单词词首的字符
			dd: 删除光标所在处的行
		
	粘贴命令
		p: 缓冲区中内容如果为整行，则粘贴在当前光标所在行的下方，否则，则粘贴光标所在处的后方
		P:缓冲区中内容如果为整行，则粘贴在当前光标所在行的上方，否则，则粘贴光标所在处的前方
		
	复制命令(yank,y)
		y:复制，工作行为类型d命令
			y$
			y^
			yw
			ye
			yb
			
	可视化模式
		v: 按字符选定
		V: 按行选定
		
	撤销操作
		u
		#u
		
	撤销此前的撤销
		ctrl+r
```
# vim底行模式
```bash
1.地址定界
	:start_pos[,end_pos]
		\#: 特定的第\#行，例如5即第五行
		.: 当前行
		$: 最后一行
		\#,\#: 指定范围
		\#,+\#:左侧为起始行的绝对编号，右侧为偏移量3,+7,8行
			.,$-1: 当前行到最后第二行
			1,$: 全文
			%: 全文
		/pattern/: 从光标所在处起始向文件尾部第一次被模式所匹配的行
			/first/,$
	可同编辑命令一同使用，实现编辑操作
		d
		y
		c
		w /path/file: 将范围内的文本保存至指定的文件中
		r /path/file: 将指定文件中的文本读取到指定位置
		
2.查找
	/pattern: 从当前光标所在处向文件尾部查找能够被模式匹配到的所有字符串
	?pattern:从当前光标所在处向文件首部查找能够被模式匹配到的所有字符串
		n:下一个，与命令方向相同
		N: 上一个，与命令方向相反
		
		
3.查找并替换
	s: 末行模式的命令；使用格式:
		s/要查找的内容/替换的内容/修饰符
			要查找的内容: 可使用正则表达式
			要替换的内容: 不可使用正则表达式，但可以引用
				如果“要查找的内容”部分在模式中分组符号，后向引用
				直接引用查找模式匹配到的全部文本，&符号
			修饰符
				i: 忽略大小写
				g: 全局替换
		可把分隔符替换为其他非常用符号
			s@@@ s###
	示例:
		%s@\<t\([[:alpha:]]\+\)\>@T\1@g
		%s@\<t[[:alpha:]]\+\>@&er@g
	
	练习
		1.复制/etc/grub2.cfg文件至/tmp目录中，用查找命令替换命令删除/tmp/grub1.cfg文件中以空白字符开头的行的行首的空白字符
			%s@^[[:space:]]\+\([^[:space:]].*\)@\1@
			
		2.复制/etc/rc.d/init.d/function文件至/tmp目录中，用查找替换命令为/tmp/functions文件的每个以空白字符开头的行的行首加上#
			%s@^[[:space:]]@#@g
			
		3.为/tmp/grub2.cfg文件的第三行的行首加上#号
			3s@^.@#&@
		
		4.将/etc/yum.repos.d/CenOS-Base.repo文件中所有的enabled=0替换为enabled=1,所有gpgcheck=0替换为gpgcheck=1
			%s@\(enabled\|gpgcheck\)=0@\1=1@g
			
```
# vim多文件功能
```bash
多文件
	vim file1 file2...
		:next 下一个
		:prev 上一个
		:first 第一个
		:last 最后一个
		
		退出所有文件:
			:wqall 保存所有文件并退出
			
多窗口
	-o: 水平分割窗口
	-O: 垂直分割窗口
	
	在窗口间切换: ctrl+w,ARROW
	
	注意: 单个文件也可以分割为多个窗口进行查看
		ctrl+w,s: 水平分割窗口
		ctrl+w,v: 垂直分割窗口
		ctrl+w w: 下一个
	
定制vim的工作特性
	注意: 在末行模式下的设定，仅对当前vim进程有效
	
	1.行号
		显示: set number，简写为set nu
		取消显示: set nomber, set nonu
	2.括号匹配高亮
		匹配: set showmatch,set sm
		取消: set nosm
	3.自动缩进
		启用: set ai
		禁用: set noai
	4.高亮搜索
		启用: set hlsearch
		禁用: set nohlsearch
	5.语法高亮
		启用: syntax on
		禁用: syntax off
	6.忽略大小写
		启用: set ic
		禁用: set noic
		
	获取帮助
		:help
		:help subject
```
# bash脚本编程之算数运算
```bash
+,-,*,/,%
算术运算格式
	1.let var=算术运算表达式: let num3=num1+num2
	2.var=$[算术运算表达式]: $[ $num2*$num3 ]
	3.var=$((算术运算表达式)): $(( $num3 * $num4 ))
	4.var=$(expr $ARG1 $OP $ARG2)
	
	注意: 乘法符号在有些场景中需要用转义符
	
	
增强型赋值
	变量做某种算术运算后回存至此变量中
		let i=$i+#
		let i+=#
		+=,-=,*=,/=,%=
		
	自增
		var=$[$var+1]
		let var+=1
		let var++
		
	自减
		var=$[ $var-1 ]
		let var-=1
		let var--


练习: 写一个脚本，完成如下功能
	添加三个用户
	求此三个用户的UID之和
```
# bash脚本编程之条件测试
```bash
条件测试
	判断某需求是否满足，需要由测试机制来实现
	
	如何编写测试表达式以实现所需的测试
		1.执行命令，并利用命令状态返回值来判断
			0: 成功
			1-255: 失败
		
		2.测试表达式
			test EXPRESSION: test $num1 -lt $num2
			[ EXPRESSION ]:   [ $num1 -eq $num2 ]
			
			注意:EXPRESSION两端必须有空白字符，否则为语法错误
			
		bash的测试类型
			数值测试
			字符串测试
			文件测试
			
			数值测试: 数值比较
				-eq: 是否等于;[ $num1 -eq $num2 ]
				-ne: 是否不等于
				-gt: 是否大于
				-ge: 是否大于等于
				-lt: 是否小于
				-le: 是否小于等于
				
			字符串测试
				==: 是否等于
				>: 是否大于
				<: 是否小于
				!=: 是否不等于
				=~: 左侧字符串是否能够被右侧的PATTERN配置，不是配置整个串
				-z "STRING": 判断指定的字符是否为空，空为真，不空为假
				-n "STRING": 判断指定的字符是否不空，不空为真，空为假
				
				注意: 
					字符串要加引号
					要使用[[]]
					
			文件测试
				存在性测试
					-a FILE
					-e FILE
						文件的存在性测试，存在为真，否则为假
						
				存在性及类型测试
					-b FILE: 是否存在且为块设备文件 [[ -b /dev/sda ]]
					-c FILE: 是否存在且为字符设备文件
					-d FILE: 是否存在且为目录文件
					-f FILE：是否存在且为普通文件
					-h FILE或-L FILE: 是否存在且为符号链接文件
					
				文件权限测试
					-r FILE: 是否存在并且对当前用户可读
					-w FILE: 是否存在并且对当前用户可写
					-x FILE: 是否存在并且对当前用户可执行
					
				特殊权限测试
					-u FILE: 是否存在并且拥有suid权限
					-g FILE: 是否存在并且拥有sgid权限
					-k FILE: 是否存在并且拥有sticky权限
					
				文件是否有内容
					-s FILE: 是否不空
				
				时间戳
					-N FILE: 文件自从上一次读操作后是否被修改过
					
				从属关系测试
					-O FILE: 当前用户是否为文件的属主
					-G FILE: 当前用户是否为文件的属组
					
				双目测试
					FILE1 -ef FILE2: FILE1与FILE2是否指向同一个文件系统的相同inode硬链接
					FILE1 -nt FILE2: FILE1是否新于FILE2
					FILE1 -ot FILE2: FILE1是否旧于FILE2
					
				组合测试条件
					逻辑运算
						第一种方式
							COMMAND1 && COMMAND2
							COMMAND1 || COMMAND2
							!COMMAND
							
							[-O FILE] && [-r FILE]
							
						第二种方式
							EXPRESSION1 -a EXPRESSION2
							EXPRESSION1 -o EXPRESSION2
							!EXPRESSION
							[-O FILE -a -x FILE]
```
# 向脚本传递参数
```bash
	位置参数变量
	myscript.sh argu1 argu2
		引用方式
			$1,$2...${10},${11}...
			
		轮替
			shift [n]: 位置参数轮替
	
	
	特殊变量:
		$0: 脚本文件路径本身
		$#: 脚本参数个数
		$*: 所有参数
		$@: 所有参数
```
# 过程式编程语言的代码执行顺序
```bash
顺序执行
选择执行
	if 测试条件;then
		代码片段
	fi
	
	if 测试条件;then
		代码片段
	else
		代码片段
	fi
	
	练习
		1.通过命令行参数给定两个数字，输出其中较大的数值
		
		#!/bin/bash
		if [ $# -lt 2  ];then
	        echo "need two num"
	        exit
		fi

		max=$1
		if [[ $max -lt $2 ]];then
		        max=$2
		fi
		echo "max num is $max"
		2.通过命令行参数给定一个用户名，判断其ID号奇偶性
		
		#!/bin/bash
		if [[ $# -lt 1 ]];then
		        echo "need user name"
		fi
		
		id -u $1 && id=$(id -u $1)
		
		if [ $(( $id%2 )) -eq 0 ];then
		        echo "user id 是偶数"
		else
		        echo "user id 是奇数"
		fi
		
		3.通过命令行参数给定两个文本文件名，如果某文件不存在，则结束脚本执行，都存在时返回每个文件的行数，并说明其中行数较多的文件
		#!/bin/bash
		if [[ $# -lt 2 ]];then
		        echo "need two file "
		fi
		
		[[ -e $1 ]] ||{ echo "$1 no exist " ; exit; }
		[[ -e $2 ]] ||{ echo "$2 no exist " ; exit; }
		
		file1_count=$(cat $1 | wc -l)
		file2_count=$(cat $2 | wc -l)
		echo $file1_count
		if [[ $file1_count -lt $file2_count ]];then
		        echo "$1=$file1_count $2=$file2_count max_count=$1"
		else
		
		        echo "$1=$file1_count $2=$file2_count max_count=$2"
		fi

		
循环执行
	for循环
		两种格式
			遍历列表
				LIST生成
					直接给出
					整数列表
						{1.100}
						seq 1 100
					返回列表的命令
					glob
			控制变量
		遍历列表
			for varaible in LIST ;do
				循环体
			done
			
	练习
		1.分别求100以内所有偶数之和，以及所有奇数之和
			#!/bin/bash
			jishu=0
			oushu=0
			for num in {1..100};do
			        if [ $(($num%2)) -eq 0 ] ;then
			                oushu=$[ $num+$oushu ]
			        else
			                jishu=$[ $num+$jishu ]
			        fi
			done
			echo "jishu=$jishu,oushu=$oushu"

		2.计算当前系统上的所有id之和
			#!/bin/bash
			sum_id=0
			for id in $(cat /etc/passwd | cut -d : -f 3) ;do
			        sum_id=$[ $sum_id+$id ]
			done
			echo "系统所有用户id和为: $sum_id"

		3.通过脚本参数传递一个目录给脚本，而后计算此目录下所有文本文件的行数之和，并说明此类文件的总数
			#!/bin/bash
			line_count=0
			file_count=0
			for file in $(find $1 -type f);do
			        ((file_count++))
			        line=$(wc -l $file | cut -d " " -f 1)
			        line_count=$(($line+$line_count))
			done
			echo "line_count=$line_count,file_count=$file_count"
		
		
```
# 脚本编程之与用户交互、语法检测、调试执行
```bash
用户交互: 通过键盘输入数据，从而完成变量赋值操作
read [option]... [name...]
	-p "prompt" 
	-t timeout
	
bash -n /path/some_script

bash -x /path/some_script
```
# 文件查找locate,find
```bash
locate:
	依赖于事先构建好的索引库
		系统自动实现(周期性任务)
		手动更新数据库(updatedb)
	工作特性
		查找速度快
		模糊查找
		非实时查找
		
	locate [OPTION]... PATTERN...
		-b: 只匹配路径中的基名
		-c: 统计出共有多少个符合条件的文件
		-r: BRE
	注意: 索引构建过程需要遍历整个根文件系统，极消耗资源
	
find: 
	实时查找工具，通过遍历指定起始路径下的文件系统层级结构完成文件查找
	工作特性
		查找速度快
		精确查找
		实时查找
	用法
		find [options] [查找起始路径] [查找条件] [处理动作]
			查找起始路径: 指定搜索范围，默认当前目录
			查找条件: 指定的查找标准，可以根据文件名，大小，类型，从属关系，权限等标准进行，默认为找出当前路径的全部文件
			处理动作: 对符合查找条件的文件做出的操作，例如删除
			
		查找条件:
			表达式: 选项和测试
			测试:
				根据文件名查找
					-name "pattern"
					-iname "pattern"
						支持glob风格的通配符
							*,?,[],[^]
							
					-regex pattern:基于正则表达式查找文件，匹配的是整个路径，而非其名
			
				根据从属关系查找:
					-user USERNAME: 查找属主指定用户的所有文件
					-group GRPNAME: 查找属组指定组的所有文件
					
					-uid UID: 查找属主指定UID的所有文件
					-gid GID: 查找属组指定GID的所有文件
					
				根据文件类型查找:
					-type TYPE
						f: 普通文件
						d: 目录文件
						l: 符号链接文件
						b: 块设备文件
						c: 字符设备文件
						p: 管道文件
						s: 套接字文件
						
				组合测试:
					 与: -a，默认组合逻辑
					 或: -o
					 非: -not,!
					 
				根据文件大小查找
					-size [+|-]#UNIT
						常用单位: k,M,G
						
						#UNIT: (#-1,#]
						-#UNIT: [0,#-1]
						+#UNIT: (#,oo)
				
				根据时间戳查找:
					以“天”为单位:
						-atime[+|-]# 访问时间
							#: [#,#-1)
							-#: (#,0)
							+#: (oo,#-1]
						-mtime 修改时间
						-ctime 改变时间
					 以“分钟”为单位
						 -amin
						 -mmin
						 -cmin
				
				根据权限查找
					-perm [/|-]mode
						mode: 精确权限匹配
						/mode: 任何一类用户(u,g,o)的权限中的任何一位(r,w,x)满足即可
						-mode:每一类用户(u,g,o)的权限中的每一位(r,w,x)同时符合条件即满足
		
		处理动作
			-print: 输出至标准输出，默认动作
			-ls: 类似于对查找到的文件执行"ls -l"命令，输出文件的详细信息
			-delete: 删除查找到的文件
			-fls /PATH/FILE: 把查找到的所有文件的长格式信息保存至指定文件
			-ok COMMAND {} \; :对查找到的每个文件执行由COMMAND表示的命令
			-exec COMMAND {} \; :对查找到的每个文件执行由COMMAND表示的命令,无用户确认提示
			注意：find传递查找到的文件路径至后面的命令时，是先查找出所有符合文件的文件路径，并一次性传递给后面的命令，但是有些命令不能接受过长的参数
			find | xargs COMMAND
练习:
	1.找出/tmp目录下属主为非root的所有文件
		find /tmp -type f -not -user  root -ls
	2.找出/tmp目录下文件名中不包含fstab字符串的文件
		find /tmp -type f -not -name "*fstab*" -ls
	3.找出/tmp目录下属主为非root,而且文件名不包含fstab的文件
		find /tmp -not \( -user root -o -name "*fstab*" \) -ls
		
	!A -a !B = !(A -o B)
	!A -o !B = !(A -a B)
	
	
	1.找出/var目录下属主为root,且属组为mall的所有文件或目录
		find /var -user root -and -group mall -ls
	2.查找/usr目录下不属于root,bin或hadoop的所有文件或目录，两种方法
		find /usr -not -user root -not -user bin -not -user hadoop -ls
		find /usr -not \( -user root -o -user bin -o -user hadoop \) -ls 
	3.查找/etc目录下最近一周内其内容修改过，且属主不是root用户也不能hadhoop用户的文件或目录
		find /etc -mtime -7 -a -not  -user root -a -user hadhoop -ls
		find /etc -mtime -7 -a -not \( -user root -o -user hadhoop \) -ls
	4.查找当前系统上没有属或属主，且最近一周内曾被访问过的文件或目录
		find /etc -mtime -7 -a -not \( -user root -o -user hadhoop \) -ls
	5.查找/etc目录下大于1M且类型为普通文件的所有文件
		find /etc -type f -size +1M -ls
	6.查找/etc目录下所有用户都没有写权限的文件
		find /etc -type f -not  -perm /222 -ls
	7.查找/etc目录至少有一类用户没有执行权限的文件
		find /etc -type f -not -perm -111 -ls
	8.查找/etc/init.d目录下，所有用户都有执行权限，且其他用户有写权限的所有文件
			find /etc/init.d -perm -111 -a -perm -002 -ls
		
	全部都有取反=>至少有一类没有
	任意一个有取反=> 全部都没有
	
	
	
```
