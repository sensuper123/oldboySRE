# 编程语言的分类
```bash
编程语言的分类
	根据运行的方式
		编译运行: 源代码->编译器(编译)->程序文件
		解释运行: 源代码->运行时启动的解释器，由解释器边解释边运行
	根据其编程过程中功能的实现是调用库还是调用外部的程序文件
		shell脚本编程
			利用系统上的命令及编程组件进行编程
		完整编程
			利用库或编辑组件进行编程
	根据编程模型: 过程式编程语言、面向对象的编程语言
		程序=指令+数据
			过程式: 以指令为中心来组织代码，数据服务于代码
				顺序执行、选择执行、循环执行
			对象式: 以数据为中心来组织代码，围绕数据来组织指令
				类(class): 实例化对象,method
				代表: java c++ python
				
	shell脚本编程: 过程式编程，解释运行，依赖外部程序文件运行
	
如何写shell脚本
	脚本文件的第一行，顶格:给出shebang，解释器路径，用于指明解释运行当前脚本的解释器程序文件
	常见解释器
		#!/bin/bash
		#!/usr/bin/python
		#!/usr/bin/perl
运行shell脚本
	(1)赋予执行权限，并直接运行此程序文件
		chmod +x /FILE
		/PATH/FILE
	(2)直接运行解释器，将脚本以命令行参数传递给解释器程序
		bash /PATH/FILE
	注意：脚本中的空白行会被解释器忽略
		脚本中，除了shebang，余下所有以\#开头的，都会被视作注释忽略
		
练习:写一个脚本，实现以下功能
	1.显示/etc目录下所有以大写p或小写p开头的文件或目录本身
	2.显示/var目录下所有文件或目录本身，并将显示结果中的小写字母转换为大写后显示
	3.创建临时文件/tmp/myfile.XXX
	
	#!/bin/bash
	ls -d /etc/[pP]*
	ls -d /var/* | tr "a-z" "A-Z"
	mktemp /tmp/myfile.XXX
	
文本编辑器: nano
	行编辑器:sed
	全屏编辑器:vi vim nano
	
	
```
# bash配置文件
```bash
两类
	profile类: 为交互式登录的shell进程提供配置
	bashrc类: 为非交互式登录的shell进程提供配置
登录类型
	交互式登录shell进程
		直接通过某终端输入账号密码后登录打开的shell进程
		使用su命令: su - username | su -l username切换登录
	非交互式登录shell进程
		su username切换登录
		图形界面下打开的终端
		运行脚本
profile类
	全局:对所有用户都生效
		/etc/profile
		/etc/profile.d/*.sh
	用户个人: 仅对当前用户有效
		~/.bash_profile
	功用:
		1.用于定义环境变量
		2.用户运行脚本和命令

bashrc类
	全局
		/etc/bashrc
	个人
		~/.bashrc
	功用
		定义本地变量
		定义命名别名
	注意: 仅管理员可修改全局配置文件
	
交互式登录shell进程文件访问顺序
	/etc/profile->/etc/profile.d/* ->~/.bash_profile-> ~/.bashrc -> /etc/bashrc

非交互式登录shell进程
	~/.bashrc -> /etc/bashrc -> /etc/profile.d/*
	
	
让通过配置文件定义的特性立即生效
	1.通过命令行重新定义一次
	2.让shell进程重读配置文件
		source /path/conf_file
		. /path/conf_file
```
# 文件处理工具及grep、egrep
```bash
Linux上文本处理三剑客
	grep: 文本过滤工具(模式: pattern)工具
	sed: stream editor，流编辑器;文本编辑工具
	awk: linux上实现为gawk，文本报告生成器(格式化文本)

正则表达式: Regual Experssion REGEXP
	由一类特殊字符及文本字符所编写的模式，其中有些字符不表示其字面意义，而是用于表示控制或通配功能
	分两类
		基本正则表达式: BRE
		扩展正则表达式: ERE
	
grep: Global search REgular expression and Print out the line
	作用: 文本搜索工具，根据用户指定的模式对文本进行逐行匹配检查，打印匹配的行
	模式: 由正则表达式的元字符以及文本字符所编写的过滤条件
	
	grep [options] PATTERN [FILE...]
	grep [options] [-e PATTERN | -f FILE] [FILE...] 
	
	选项: 
		--color=auto: 对匹配到的文本着色后高亮显示
		-i: ignorecase,忽略字符的大小写
		-o: 仅显示匹配到的字符本身
		-v: 显示不能被模式匹配到的行
		-E：支持使用扩展的正则表达式元字符
		-q: 静默模式，即不输出任何信息
		
		-A #: after,后#行
		-B #: before,前#行
		-C #: context,前后各#行

egrp
	支持扩展的正则表达式实现类似于grep -E
	egrp [options] PATTERN [FILE...]
		选项
		-i,-o,-v,-q,-A,-B,-C
		-G: 支持基本正则表达式
```
# 基本正则表达式
```bash
字符匹配
	.: 匹配任意单个字符
	[]: 匹配指定范围内的任意单个字符
	[^]: 匹配指定范围外的任意单个字符
		[:dight:] [lower:] [:upper:] [:alpha:] [:alnum:] [:punct:] [:space:]
	
匹配次数: 用在要指定其出现的次数的字符的后面，用于其出现的次数
	*: 匹配其前面的字符任意次; 0,1,多次
	.*: 匹配任意长度的任意字符
	\?: 匹配其前面的字符0次或1次，即可有可无
	\+: 匹配前面的字符1次或多次，至少要出现一次
	\{m\}: 匹配其前面字符m次
	\{m,n\}: 匹配其前面字符至少m次，至多n次
		\{0,n\}: 至多n次
		\{m,\}: 至少m次
		
位置锚定
	^: 行首锚定
	$: 行尾锚定
	^PATTERN$: 匹配整行
		^$: 空白行
		^[[:space:]]*$: 空行或包含空白字符的行
	单词: 非特殊字符组成的连续字符
	\<或\b: 词首锚定，用于单词模式的左侧
	\>或\b: 词尾锚定，用于单词模式的右侧
	\<PATTERN\>: 匹配完整单词
	
练习
	1.显示/etc/passwd文件中不以/bin/bash结尾的行
		grep -v "/bin/bash$" /etc/passwd
	2.找出/etc/passwd文件中的两位数或三位数
		grep "\b[0-9]\{2,3\}\b" /etc/passwd
		grep "\<[0-9]\{2,3\}\>" /etc/passwd
	3.找出/etc/grub2.cfg文件中，以至少一个空白字符开头，且后面非空字符的行
		grep "^[[:space:]]\+[^[:space:]]*" /etc/grub2.cfg
	4.找出"netstat -tan"命令的结果中以'LISTEN'后跟0、1或多个空白字符结尾的行
		netstat -tan | grep "LISTEN[[:space:]]*$"
	
	
分组及引用
	\(\): 将一个或多个字符捆绑在一起

练习: 匹配前面与后面一样的行
	he lover his lover
	he likes his lover
	she likes her liker
	she loves her liker
	grep "\(l...r\).*\1" lover.txt #后向引用
```
# 扩展正则表达式
```bash
扩展正则表达式的元字符
	字符匹配
		.: 任意单个字符
		[]: 指定范围内的任意单个字符
		[^]: 指定范围外的任意单个字符
	
	次数匹配
		*: 任意次，0,1或多次
		?: 0或1次
		+: 最少一次
		{m}: 当前字符至少一次
		{m,n}: 至少m次，至多n次
			{0，n}: 至多n次
			{m,}: 至少m次
	
	位置锚定
		^: 行首锚定
		$: 行尾锚定
		\<,\b: 词首锚定
		\>,\b: 词尾锚定
	
	分组及引用
		(): 分组，括号内的模式匹配到的字符会被记录于正则表达式引擎的内部变量中
		
	或
		a | b: a或者b
			C|cat: C或cat
			(C|c)at: Cat或cat
			
练习
	1.找出/proc/meminfo文件中，所有以大写或小写S开头的行，至少三种
		grep -i "^s" /proc/meminfo
		grep "^[sS]" /proc/meminfo
		egrep "^(s|S)" /proc/meminfo
		
	2.显示当前系统上root,centos或user1用户的相关信息
		egrep "^(root|centos|user1)[^[:alnum:]]" /etc/passwd
		
	3.找出/etc/rc.d/init.d/functions文件中某单词后面跟一个小括号行
		egrep -o  "[_[:alnum:]]+\(\)" /etc/rc.d/init.d/functions
	
	4.使用echo命令输出一绝对路径，使用egrep取出基名
		echo /etc/sysconfig | egrep -o "[[:alnum:]]+/?$"
		echo /etc/sysconfig | egrep -o "[^/]+/?$"
	5.找出ifconfig命令结果中的1-255之间的数值
		ifconfig | egrep "\<([1-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\>"
	6.找出ifconfig命令结果中的IP地址
		ifconfig | grep "inet\>" | tr -s ' ' ":" | cut -d: -f 3
	7.添加用户bash,testbash,basher以及nologin(其sehll为/sbin/nologin);而后找出/etc/passwd文件中用户名与sehll名相同的行
		egrep "^([^:]+).*\1$" /etc/passwd

fgrep: 不支持正则表达式元字符
	当无需要用到元字符去编写模式时，使用fgrep
```
# 文本查看及处理工具wc,cut,sort,uniq,diff,patch
```bash
wc: word count
	wc [OPTION]... [FILE]...
		-l: line
		-w: words
		-c: bytes

cut:
	cut OPTION...[FILE]...
		OPTION:
			-d CHAR: 以指定的字符为分割
			-f: 挑选出的字段
				#: 单个字段
				#-#: 连续多个字段
				#,#: 离散多个字段
				
sort
	sort [OPTION]... [FILE]...
		-n: 基于数值大小而非字符进行排序
		-t CHAR: 指定分隔符
		-k #: 用于排序比较的字段
		-r: 逆序排序
		-f: 忽略字符大小写
		-u: 重复的行只保留一份
		
uniq: 报告或移除重复的行
	uniq [OPTION]... [INPUT[OUTPUT]]
	-c: 显示每行的重复次数
	-u: 仅显示未重复的行
	-d: 仅显示重复过的行
	
diff: compare file line by line
	diff /path/oldFile /path/newFile > /path/patch_file
		-u: 使用unfied机制，即显示要修改的行的上下文，默认3行
		
patch: 向文件打补丁
	patch [options] -i /path/patch_file /path/old_File
	pathch /path/oldFile < /path/patch_file
	
练习：取出ifconfig eno 命令结果中的ip地址
```