# linux系统管理
```bash
磁盘分区及文件系统管理
RAID
LVM
网络属性管理
程序包管理
sed and awk
进程查看和管理
内核管理(编译安装)
系统启动流程
定制、编译内核、busybox
系统安装: klckstart,dhcp,pxe
shell脚本编程
```

# linux磁盘及文件系统管理
```bash
CPU、Memory(RAM)、I/O
I/O:
	Disks硬盘,Ehtercard网卡
		接口类型:
			IDE(ata): 并口，133MB/s
			SCSI: 并口,Ultrascsi320,320MB/s,Ultrascsi640,640MB/s
			STAT: 串口,6gbps
			SAS: 串口,6gbps
			USB: 串口,480MB/s
			NVMe: 串口,32GB/s
			
		硬盘: 机械硬盘hhd,固态硬盘ssd
			机械硬盘:主要使用IDE,SATA,SAS
				track: 磁道
				sector: 扇区,512btyes
				cylinder: 柱面
					分区划分基于柱面
				平均寻道时间
					5400rpm,7200rpm,10000rpm,15000rpm
					
linux的哲学思想:一切皆文件
	设备类型
		块(block): 随机访问，数据交换单位是"块"
		字符(character): 线性访问，数据交换单位是"字符"
		
	设备文件:FHS
		/dev
			设备文件: 关联至设备的驱动程序;设备的访问入口
				设备号
					major: 主设备号，区分设备类型，用于标明设备所需要的驱动程序
					minor: 次设备号，区分同种类型的不同设备，是特定设备的访问入口
				mknod命令
					make block or character special files
					mknod [OPTION]... NAME TYPE [MAJOR MINOR]
						-m MODE: 创建后的设备文件的访问权限
						
	磁盘
		IDE: /dev/hd[a-z]
			例如: /dev/hda,/dev/hdb
		SCSI,STAT,USB,SAS:/dev/sd[a-z]
		
		分区
			/dev/sda#
				/dev/sda1...
		注意: Centos 6和7统统将设备文件标识为/dev/sd[a-z]#
		引用设备的方式
			设备的文件名
			卷标
			UUID


```
# 磁盘分区: MBR,GPT
```bash
MBR: 0 sector
	Master Boot Record 系统启动引导记录表
	
		分为三部分
			446bytes: bootloader程序，引导启动操作系统的程序
			64bytes: 分区表，每16bytes标识一个分区，一个只能有4分区
				4主分区
				3主1扩展
					n逻辑分区
				2bytes: MBR区域的有效性标识;55AA为有效
				
				
fdisk命令
	1.查看磁盘的分区信息:
		fdisk -l [-u] [device...]: 列出指定磁盘设备上的分区情况
	2.管理分区
		fdisk device
		fdisk提供李一个交互式接口来管理分区，它有许多子命令，分别用于不同的管理功能，所有的操作均在内存中完成，没有直接同步到磁盘，直到w命令保存至磁盘上
		常用命令
			n: 创建新分区
			d: 删除已有分区
			t: 修改分区类型
			l: 查看所有已有ID
			w: 保存并退出
			q: 退出不保存
			m: 查看帮助信息
			p: 显示现有分区信息
			
		注意：在已经分区并且已经挂载的其中某个分区的磁盘设备上创建的新分区，内核可能在创建完成后无法直接识别
		
		查看: cat/proc/parttions
		通知内核强制重读磁盘分区表
			Centos 5: partprobe [device]
			Centos6,7: partx,kpartx
```
# 创建文件系统
```bash
格式化: 低级格式化(分区之前进行，划分磁道)、高级格式化(分区之后对分区进行，创建文件系统)

	元数据区、数据区
		文件元数据: inode(index node)
			大小、权限、属主属组、时间戳、数据块指针
		
		符号链接文件: 存储数据指针的空间当中存储的是真实文件的访问路径
		设备文件: 存储数据指针的空间当中存储的是设备号(major,minor)
		
		bitmap index: 位图索引
		
	VFS: Virtual File System
		linux的文件系统:ext2,ext3.ext4,xfs,btrfs
		光盘: iso9660
		网络文件系统: nfs,cifs
		集群文件系统: gfs2,ocfs2
		windows文件系统: vfat,ntfs
		伪文件系统: proc,sysfs,tmpfs,hugepagefs
		Unix文件系统: UFS,FFS,JFS
		交换文件系统: swap
		用户空间的分布式文件系统: mogllefs,moosefs,glusterfs

文件系统管理工具
	创建文件系统的工具
		mkfs
			mkfs.ext2,mkfs.ext3,mkfs.ext4,mkfs.vfat...
	检测及修复文件系统的工具
		fsck
			fsck.ext2,fsck.ext3
	查看其属性的工具
		dumpe2fs,tune2fs
	调整文件系统的特性
		tune2fs	
		
```
# 文件系统个人理解
```bash
1.创建文件系统就是把一块磁盘格式化，分为多个组，每个组里面有元数据区，数据区
2.每个组的文件系统逻辑上都是独立的，各自有各自的inode,block编号,但是如果一个文件过大，一个组的文件系统存储不下，也可以夸文件系统存储
3.元数据区inode存储文件的元数据: 大小、时间戳、属主属组、权限、数据块指针
4.每个组的元数据区都有各自的超级块，Block Group Descriptor块组描述符，存储的有组文件系统大小(组块总数)、位图描述符等
5.还有一个superBlock超级块，存储的是全局信息，例如文件系统大小(总块数、块大小、空闲块数量、空闲inode数量)
```
# 软硬链接
```bash
链接文件: 访问同一个文件不同路径
	硬链接: 指向同一个inode的多个文件路径
		特性:
			目录不支持硬链接
			硬链接不能跨文件系统
			创建硬链接会增加inode引用计数
		创建
			ln src link link_file
	
	符号链接: 指向一个文件路径的另一个文件路径、
		特性
			符号链接与文件是两个各自独立的文件，各有自己的inode，对源文件创建符号链接不会增加引用计数
			支持对目录创建符号链接，可以跨文件系统
			删除符号链接文件不影响原文件，但删除源文件，符号指定的路径即不存在，此时会变成无效链接
			
			注意: 符号链接文件的大小是其指定的文件的路径字符的串字数
			
		创建:
			ln -s src link_file
			-v: verbose 显示过程
```
# 磁盘和文件系统管理
```bash
文件系统管理工具
	创建文件系统的工具
		mkfs
			mkfs.ext2,mkfs.ext3,mkfs.ext4,mkfs.vfat...
	检测及修复文件系统的工具
		fsck
			fsck.ext2,fsck.ext3
	查看其属性的工具
		dumpe2fs,tune2fs
	调整文件系统的特性
		tune2fs	
		
内核级文件系统的组成部分
	文件系统驱动: 由内核提供
	文件系统管理工具: 由用户空间的应用程序提供
	
ext系统文件系统的管理工具
	mkfs.ext2,mkfs.ext3,mkfs.ext4
	mkfs -t ext2= mkfs.ext2
	
	ext系统文件系统专用管理工具: mke2fs
		mke2fs [OPTIONS] device
			-t {ext2|ext3|ext4}: 指明要创建的文件系统类型
				mkfs.ext4=mkfs -t ext4=mke2fs -t ext4
			-b {1024|2048|4096}: 指明文件系统的块大小
			-L LABEL: 指明卷标
			-j: 创建有日志功能的文件系统ext3
				mke3fs -j=mke2fs -t ext3=mkfs -t ext3=mkfs.ext3
			-i\#: bytes-per-inode,指明inode与字节的比率
			-N\#: 直接指明要给此文件系统创建的inode数量
			-O [^]FEATURE: 以指定的特性创建目标文件系统 
			
		e2label命令: 卷标的查看与设定
			查看: e2label device
			设定: e2label device LABEL
			
		tune2fs命令: 查看或修改ext文件系统的某些属性
			注意: 块大小创建后不可修改
			
			tune2fs [OPTIONS] device
				-l: 查看超级块的内容
				
					修改指定文件系统的属性
						-j: ext2 --> ext3
						-L LABEL: 修改卷标
						-m#: 调整预留空间百分比
						-O[^]FEATURE: 开启或关闭某种特性
						-o [^]mount_options: 开启或关闭某种默认挂载选项
							acl,^acl
						
		dumpe2fs命令: 显示ext系列文件系统属性信息
			dumpe2fs -[h] device
		
		用于实现文件系统检查的工具
			因进程意外中止或系统崩溃等原因导致定稿操作非正常终止时，可能会造成文件损坏，此时，应该检测并修复文件系统，建议离线进行
			
		ext系列文件系统的专用工具
			e2fsck: check a linux ext2/ext3/ext4 file system
				e2fsck [OPTIONS] device
					-y: 对所有问题自动回答为yes
					-f: 即时文件系统处于clean状态，也要强制检测
			
			fsck: check and repair a linux file system
				-t fstype: 指明文件系统类型
					fsck -t ext4 = fsck.ext4
				-a: 无须交互而自动修复所有错误
				-r: 交互式修复
				
blkid命令
	blkid device
	blkid -L LABEL: 根据LABEL定位设备
	blkid -U UUID: 根据UUID定位设备
	
	
swap交互系统
	linux上的交换分区必须使用独立的文件系统
		且文件系统的system ID 必须为82
		
	创建swap设备: mkswap命令
		mkswap [OPTIONS] device
			-L LABEL: 指明卷标
			-f: 强制
			
windows无法识别linux的文件系统;因此，存储设备需要两种系统直接交叉使用时，应该使用Windows和linux同时支持的文件系统:fat32(vfat)
	mkfs.vfat device
```
# 文件系统的使用
```bash
	首先要"挂载": mount命令和unmount命令
	根文件系统之外的其他文件系统要想被访问，都必须通过"关联"至根文件系统上的某个目录实现，此关联操作为"挂载"，关联目录为"挂载点"
		挂载点: mount_point,用于作为另一个文件系统的访问入口
			1.事先存在
			2.应该使用未被或不会被其他进程使用到的目录
			3.挂载点下原有的文件将会被隐藏
			
mount命令
	mount [-nrw] [-t vfstype] [-o options] device dir
	
		命令选项
			-r: readonly，只读挂载
			-w: read and write,读写挂载
			-n: 默认情况下，设备挂载或卸载的操作会同步更新至/etc/mtab文件中，-n用于禁止此特性
			-t vfstype: 指明要挂载的设备上的文件系统类型，可省略
			-L LABEL: 挂载时以卷标的方式指明设备
				mount -L LABEL dir
			-U UUID: 挂载时以UUID的方式指明设备
				mount -U UUID dir
				
		-o options: 挂载选项
			sync/async: 同步/异步操作
			atime/noatime: 文件或目录在被访问时是否更新其访问时间戳
			diratime/nodiratime: 目录在被访问时是否更新其访问时间戳
			remount: 重新挂载
			acl: 支持使用facl功能
				mount -o acl device dir
				tune2fs -o acl device
				
			ro: 只读
			rw: 读写
			dev/nodev: 此设备是否允许创建设备文件
			exec/noexec: 是否允许运行此设备上的程序文件
			user/nouser: 是否允许普通用户挂载此文件系统
			suid/nosuid: 是否允许程序文件上的suid和sgid权限生效
			
			defaults: Use default options:rw,suid,dev,exec，auto,nouser,async and relatime
			
一个使用技巧:
	可以实现将目录绑定到另一个目录上，作为其临时访问入口
		mount --bind 源目录 目标目录
		
查看当前系统所有已挂载的设备
	mount
	cat /etc/mtab
	cat /proc/mounts
	
挂载光盘:
	mount -r /dev/cdrom mount_point
	光盘设备文件:/dev/cdrom,/dev/dvd
	
挂载U盘
	事先识别U盘的设备文件
	
挂载本地的回环设备
	mount -o loop /PATH/LOOP_FILE MOUNT_POINT
	
交换分区的启用和禁用
	创建交换分区的命令: mkswap
	启用: swapon
		swapon [option] [device]
	禁用: swapoff
		swapoff DEVICE
		
		
umount命令
	unmount device | dir
	
	注意: 正在被进程访问到的挂载点无法被卸载
		查看被哪个或哪些进程所访问
			lsof MOUNT_POINT
			fuser -v MOUNT_POINT
			
设定除根文件系统以外的其他文件系统能够开机自动挂载/etc/fstab
	每行定义一个要挂载的文件系统及相关属性
		6个字段
			1.要挂载的设备
				设备文件
				LABEL
				UUID
				伪文件系统: 如sysfs,proc,tmpfs等
			2.挂载点
				swap类型的设备的挂载点为swap
			3.文件系统类型
			4.挂载选项
				defaults:使用默认挂载选项
				如果要同时指明多个挂载选项，彼此间以逗号分割
					defaults,acl,noatime,noexec
					
					
两个命令: df 和 du
	df命令
		df [options]... [file]...
			-l: 仅显示本地文件的相关信息
			-h: human-readable
			-i: 显示inode的使用状态而非block
			
	du命令
		du [option]... [file]...
			-s: sumary
			-h: human-readable
			
			
练习: 
	1.创建一个10G的分区，并格式化为ext4文件系统
	2.挂载至/mydata目录，要求挂载时禁止程序自动运行，且不更新文件的访问时间戳
	3.可开机自动挂载
	
	4.创建一个大小为1G的swap分区，并启动之
```
# 删除文件和复制、粘贴文件
```bash
删除文件: 将此文件指向的所有data block标记为未使用状态;将此文件的inode标记为未使用

复制和移动文件
	复制: 新建文件
	移动:
		在同一文件系统: 改变的仅是其路径，例如目标目录创建新文件，然后把文件的inode指向旧文件的inode，再删除旧文件目录下的文件，目录下的文件其实是路径映射
		在不同文件系统: 复制数据至目标文件，并删除源文件
```
# RAID
```bash
Redundant Arrays of Inexpensive Disks 廉价(独立)磁盘冗余阵列

RAID作用
	提高IO能力
		磁盘并行读写
	提高耐用性
		磁盘冗余来实现
	级别: 多块磁盘组织在一起的工作方式有所不同
	RAID实现的方式
		外接式磁盘阵列: 通过扩展卡提高适配能力
		内接式RAID: 主板集成RAID控制器
		software RAID:
		
		
级别: level
	RAID-0: 0,条带卷，strip
	RAID-1: 1,镜像卷，mirror
	RAID-2
	RAID-5
	RAID-6
	RAID-10
	RAID-01
	
	RAID-0:
		读写性能提升
		可用空间: N*min(S1,S2...)
		无容错能力
		最少磁盘数: 2
		
	RAID-1:
		读性能提升、写性能略有下降
		可用空间: N/2*min(S1,S2...)
		有冗余能力
		最少磁盘数: 2 
		
	RAID-4
	
	RAID-5
		读写性能提升
		可用空间:(N-1)*min(S1,S2...)
		有容错能力: 1块磁盘
		最少磁盘数: 3
		
	RAID-6
		读写性能提升
		可用空间: (N-2)*min(S1,S2...)
		有容错能力: 2块磁盘
		最少磁盘数: 4
		
	RAID-10
		读写性能提升
		可用空间:N*min(S1,S2)/2
		有容错能力: 每组坏一个
		最少磁盘数: 4
		
	RAID-01
		读写性能提升
		可用空间:N*min(S1,S2)/2
		有容错能力: 每组不能同时坏一个
		
		
实现方式
	硬件实现方式
	软件实现方式
	CentOS 6上软件RAID的实现
		结合内核中的md(multi devices )
		
		mdadm: 模式化的工具
			命令的语法格式: mdadm [mode] <raiddevice> [options] <component-device>
			
		模式:
			创建: -C
			装配: -A
			监控: -F
			管理: -f,-r.-a
			
		<raiddevice>: /dev/md#
		<component-device>: 任意块设备
		
		-C: 创建模式
			-n #: 使用#个块设备来创建此RAID
			-l #: 指明要创建的RAID级别
			-a {yes|no}: 自动创建目标RAID设备的设备文件
			-c CHUNK_SIZE: 指明块大小
			-x #: 指明空闲盘的个数
			
		-D: 显示raid的详细信息
			mdadm -D /dev/md#
			
		管理模式
			-f: 标记指定磁盘为损坏
			-a: 添加磁盘
			-r: 移除磁盘
			
		观察md的状态
			cat /proc/mdstat
			
		停止md设备
			mdadm -S /dev/md#
			
watch命令
	-n #: 刷新间隔，单位是秒
	watch -n# 'COMMAND'
			
			
			
	练习1: 创建一个可用空间为10G的RAID1设备，要求其chunk大小为128K，文件系统为ext4,有一个空闲盘，开机可自动挂载至/backup目录
	 mdadm -C -n 2 -l 1 -a yes -c 128 -x 1 /dev/md0 /dev/sdb5 /dev/sdb6 /dev/sdb7

	练习2: 创建一个可用空间为10G的RAID10设备，要求其chunk大小为256K，文件系统为ext4,开机可自动挂载至/mydata目录
		
		
```

# LVM逻辑卷使用
```bash
LVM2
	LVM: logical volume manager,version 2
	dm: device mapper,将一个或多个底层块设备组织成一个逻辑设备的模块
		/dev/dm-#
	/dev/mapper/VG-NAME-LV-NAME
		/dev/mapper/vo10-root
	/dev/VG_NAME/LV_NAME
		/dev/vg10/root
		
		
	pv管理工具
		pvs: 简要pv信息显示
		pvdisplay: 显示pv的详细信息
		pvcreate /dev/DEVICE: 创建pv
		
	vg管理工具
		vgs
		vgdisplay
		
		vgcreate [-s #[kKmMgGtT]] volumeGroupName physicalDevicePath [physicaDevicePath...]
		vgextend volumeGroupName physicalDevicePath [physicalDevicePath...]
		vgreduce volumeGroupName physicalDevicePath [physicalDevicePath...]
		先做pvmove
		
	lv管理工具
		lvs
		lvdisplay
		lvcreate -L #[mMgGtT] -n NAME volumeGroup
		
	扩展逻辑卷
		lvextend -L [+]#[mMgGtT] /dev/VG_NAME/LV_NAME
		resize2fs /dev/VG_NAME/LV_NAME
		
	缩减逻辑卷
		umount /dev/VG_NAME/LV_NAME
		e2fsck -f /dev/VG_NAME/LV_NAME
		resize2fs /dev/VG_NAME/LV_NAME #[mMgGtT]
		lvreduce -L [-]#[mMgGtT] /dev/VG_NAME/LV_NAME
		mount
		
		
	快照: snapshot
		lvcreat -L #[mMgGtT] -p r -s -n snapshot_lv_name original_lv_name
		-s: 快照
		-p: permit 权限
		-n: 名字
		
		 
	练习1: 创建一个至少有两个pv组成的大小为4G的名为my_vg0 的VG,要求PE大小为16MB，而后在卷组中创建大小为2G的逻辑卷lv_users,挂载至/users目录
	pvcreate /dev/sdb5
	pvcreate /dev/sdb6
	vgcreate -s 16MB my_vg0 /dev/sdb5 /dev/sdb6
	lvcreate -L 2G -n lv_users my_vg0 
	
	mke2fs -t ext4 /dev/my_vg0/lv_users
	mount /dev/my_vg0/lv_users /users
	
	
	练习2: 创建用户archlinux，要求其家目录为/users/archlinux,而后su切换至arclinux用户，复制/etc/pam.d目录至自己的家目录
	useradd -d /users/archlinux archlinux
	cp -r /etc/pam.d /users/archlinux/
	
	练习3: 扩展lv_users至3G，要求archlinux用户的文件不能丢失
	lvextend -L 3G /dev/my_vg0/lv_users
	resize2fs /dev/my_vg0/lv_users
	练习4: 缩减lv_users至1G，要求archlinux用户的文件不能丢失
		e2fsck -f /dev/my_vg0/lv_users 
		resize2fs /dev/my_vg0/lv_users 1G
		lvreduce -L 1G /dev/my_vg0/lv_users
		
	练习5: 扩展my_vg0到6G
		vgextend my_vg0 /dev/sdb7
		
	练习7: 移除vg里的一个pv
		pvmove /dev/sdb7
		vgreduce my_vg0 /dev/sdb7
		pvremove /dev/sdb7
	练习5: 对lv_users创建快照，并尝试基于快照备份数据，验证快照的功能
		lvcreate -L 1G -s -p r -n lv_users_snapshot my_vg0/lv_users
```
# btrfs
```bash
btrfs文件系统
	核心特性:
		多物理卷支持: btrfs可由多个底层物理卷组成,支持RAID,以联机“添加”、“移除”，“修改”
		写实复制更新机制(CoW): 复制、更新及替换指针，而非就地更新
		数据及元数据校验码: checksum
		子卷: sub_volume
		快照: 支持快照的快照
		透明压缩
		
	文件系统创建
		mkfs.btrfs
			-L 'LABEL'
			-d <type>: raid0,raid1,raid5,raid6,raid10,single
			-m <profile>: raid0,raid1,raid5,raid6,raid10,single
			-O <feature>
				-O list-all: 列出支持的所有feature
				
		属性查看
			btrfs filesystem show /mnt
			btrfs filesystem df /mnt
			
		挂载文件系统
			mount -t btrfs /dev/sdb /mnt
			
		子卷
			创建子卷
				btrfs subvolum create /mnt/my_subvol
				
			列出子卷
				btrfs subvolum list /mnt
				
			挂载子卷,直接挂载父文件系统也可以
				mount -o subvol=my_subvol /dev/sdb /mnt/subvol
				
				
		快照
			btrfs subvolum snapshot -r /mnt/my_subvol /mnt/my_subvol_snapshot
			
		压缩
			挂载时启动压缩
				mount -o compress=zstd /dev/sdb /mnt
			
			对现有文件进行压缩
				btrfs filesystem defragment -czstd /mnt
			
		RAID
			创建btrfs RAID1文件系统
				mkfs.btrfs -m raid1 -d raid1 /dev/sdb /dev/sdc
			
			查看raid的状态
				btrfs filesystem df /mnt
			
		扩容缩减
			添加新设备
				btrfs device add /dev/sdc /mnt
			移除设备
				btrfs device remove /dev/sdb /mnt
				
			在线扩展挂载点
				btrfs filesystem resize +10G /mnt
				
				
		检查和修复
			检查文件系统
				btrfs scrub start /mnt
			查看状态
				btrfs scrub status /mnt 
				
		在线更换RAID级别
			从raid1转换为raid5
			btrfs balance start -dconvert=raid5 -mconvert=raid5 /mnt
			从raid5转换回raid1
			btrfs balance start -dconvert=raid1 -mconvert=raid1 /mnt
			
```
# 压缩和解压缩工具
```bash
压缩比
	目的: 时间换空间
		CPU的时间->内存的空间
		
	compress/uncompress
	gzip/gunzip
	bzip2/bunzip2
	xz/unxz
	zip/unzip
	tar,cpio
	
	1.gzip/gunzip/zcat
		gzip [option]... file...
			-d: 解压缩,相当于gunzip
			-#: 指定压缩比，默认是6，数字越大压缩比越大
			-c: 将压缩结果输出至标准输出
				gzip -c file >/path/to/file.gz
				
	2.bzip2/bunzip2/bzcat
		bzip2 [option]... file...
			-d: 解压缩
			-#: 压缩比
			-k: 保留源文件
			
	3.xz/unxz/xzcat
		xz [option]... file...
			-d: 解压缩
			-#: 压缩比
			-k: 保留源文件
		
	归档、打包: tar,cpip
		tar命令
			1.创建归档
				-cf /path/to/somefile.tar file...
			2.展开归档
				-xf /path/from/somefile.tar
				-xf /path/from/somefile.tar -C /path/to/somedir
			3.查看归档文件的文件列表
				-tf /path/to/somefile.tar
				
			归档完成通常需要压缩，结合此前的压缩工具
			4.归档并压缩
				-z: gzip2
					-zcf /path/to/somefile.gz file...
					解压缩并展开归档
					-zxf /path/from/somefile.gz 
					
				-j: bzip2
					-jcf
					-jxf
				-J: xz
```